breed [firms firm]

;defines firm specific fields
firms-own [
  firm-type                        ; # a label for the firm
  input-data                       ; the firm types and productivity that firms need to buy from
  inventory                        ; # amount of goods stored and ready to be sold
  price                            
  wage-rate                        
  
  months-failed-to-hire            ; consecutive months that firms failed to hire
  
  desired-n-workers                ; represents the desired number of workers for the month
  previous-sales

  demand                           ; the most recent demand this firm experienced for its goods     (previous-sales used in calculations instead, so we can remove this variable if we want)
  tech-parameter                   ; determines how much each worker produces given a 
  consumer-good-firm?              ; defines whether they produce consumer goods
  
  firm-location                    ; the patch tied to the firm, relevant for the potvin index
  soil-health                      ; the soil health located under the firm, possible change to patch variable?
  
  lifetime-profits                 ; the total sum of profits - startup costs
]

;firm procedure, adjusts wage rate based on previous hiring trendsd, see paper for more details
to adjust-wage-rate  
  (ifelse months-failed-to-hire >= 1 and desired-n-workers > n-workers [  ; firm had an open position last month and failed to fill
    set wage-rate (1 + random-float MAX-WAGE-GROWTH) * wage-rate
  ] months-failed-to-hire <= MONTHS-TO-LOWER-WAGE [ ; If all hires in past MONTHS-TO-LOWER-WAGE 
    set wage-rate max (list ((1 - random-float MAX-WAGE-GROWTH) * wage-rate) MIN-WAGE-RATE)
  ])
end

;firm procedure, GATTI procedure used to determine whether there needs to be a price or labor correction.
to adjust-labor-and-price
  (ifelse previous-sales >= max-production [ 
    ;excess demand
    (ifelse price > (mean [price] of firms-with-my-type) [ 
      set desired-n-workers floor (previous-sales / tech-parameter) ; excess demand and price is already higher than average, decrease output
    ] [
      set price price * (1 + random-float MAX-PRICE-GROWTH)         ; excess demand, but price is lower than average, increase price
    ])
  ] [
    ;excess supply
    (ifelse price < (mean [price] of firms-with-my-type) [
      set desired-n-workers floor (previous-sales / tech-parameter) ; excess supply and price is already lower than average, increase output.
    ] [  
      set price price * (1 - random-float MAX-PRICE-GROWTH)         ; excess supply, but price is higher than average, lower price
    ])
  ])
  if desired-n-workers < 0 [error "Unable to fire a worker that does not exist"]
end


;firm procedure, decides whether or not to fire a worker at the end of the next time period
to decide-fire-worker
  if desired-n-workers < n-workers and n-workers > 0 [  
    ask one-of my-employment-links [die]
  ]
end

;firm procedure, determines whether exit is an appropriate response for the firm this period
to remove-firm
  add-lifetime-profits
  if replace-exited-firm? [
    add-firm
  ]
  die
end

;firm procedure, adds the firms lifetime-profits to the list of total lifetime-profits
to add-lifetime-profits
  set LIFETIME-PROFITS-LIST (lput lifetime-profits LIFETIME-PROFITS-LIST)
end


;firm procedure, adds in another firm of a given firm type
to add-firm
  set TOTAL-BANKRUPT-FIRMS TOTAL-BANKRUPT-FIRMS + 1
  hatch 1[
    set color yellow                    ; set color to yellow for one month to visually indicate which firms are going bankrupt
    set price mean [price] of firms-with-my-type
    set wage-rate mean [wage-rate] of firms-with-my-type
    set liquidity raise-funds
    set lifetime-profits liquidity * -1
    set desired-n-workers (floor (mean [demand] of firms-with-my-type / tech-parameter))
    set demand desired-n-workers * tech-parameter
    set months-failed-to-hire 0
    set-input-demands
    foreach table:keys input-data [i ->
      set-stock i 0
    ]
    
    if consumer-good-firm? [
      set CONSUMER-GOOD-FIRMS (turtle-set CONSUMER-GOOD-FIRMS self)
    ]
    if table:length input-data = 0 [
      set PRIMARY-GOOD-FIRMS (turtle-set PRIMARY-GOOD-FIRMS self)
    ] 
    if not consumer-good-firm? and table:length input-data != 0[
      set INTERMEDIATE-GOOD-FIRMS (turtle-set INTERMEDIATE-GOOD-FIRMS self)
    ]
  ]
end

;firm procedure, updates the soil health of the patches 
to update-soil-health
  set soil-health min (list 200 (soil-health + BACKGROUND-IMPROVEMENT))
  set soil-health max (list 0 (soil-health - (max-production)))
  let patch-health soil-health
  ask firm-location [
    set pcolor scale-color black patch-health 0 200
  ]
end

;firm procedure, guarantees the correct number of trading links per consumer good firm after removing any expired 
to guarantee-framework-links [input-i]
  ask my-framework-agreements with [expiration-date >= month] [
    init-framework-agreement index-type framework-duration    ; "renegotiate" we currently use the same input type
  ]
  let curr-framework-links count my-framework-agreements with [input-firm-type = input-i]
  if curr-framework-links < N-FRAMEWORK-AGREEMENTS [
    create-framework-agreements-from n-of (N-FRAMEWORK-AGREEMENTS - curr-framework-links) firms with [firm-type = input-i and not in-framework-agreement-neighbor? myself][
      (ifelse use-index? [
        init-framework-agreement ((random 4) + 1) framework-duration
      ] [
        init-framework-agreement 0 framework-duration
      ])
    ]
  ]
end

;firm procedure, firms search for the funding from households
to-report raise-funds
  let to-be-raised STARTUP-LIQUIDITY
  let new-firm self
  let current-price mean [price] of CONSUMER-GOOD-FIRMS
  while [to-be-raised > 0] [
    ask one-of households with [not equity-link-neighbor? new-firm][ 
      let liquidity-available (liquidity - AUTONOMOUS-CONSUMPTION * current-price) * 0.5
      if liquidity-available > 0 [
        ifelse liquidity-available > to-be-raised [
          create-equity-link-with new-firm [
            init-equity-link
            set equity to-be-raised 
          ]
          set liquidity liquidity - to-be-raised
          set to-be-raised 0
        ] [
          create-equity-link-with new-firm [
            init-equity-link
            set equity liquidity-available 
          ]
          set liquidity liquidity - liquidity-available
          set to-be-raised to-be-raised - liquidity-available
        ]
      ]
    ]
  ]
  if precision sum [equity] of my-equity-links 2 != STARTUP-LIQUIDITY [
    error "funds were not raised"
  ]
  report STARTUP-LIQUIDITY
end


;firm procedure, searches for a cheaper supplier of a given input good
to search-cheaper-supplier [input-i]
  if count my-in-framework-agreements with [input-firm-type = input-i] = 0 [error "must have at least one framework agreement"]
  let current-framework-agreement max-one-of my-in-framework-agreements with [input-firm-type = input-i] [[price] of end1]
  let random-firm pick-random-input-firm input-i
  let current-price [price] of [other-end] of current-framework-agreement
  if ([price] of random-firm)  < current-price [
    ask current-framework-agreement [die]
    create-framework-agreement-from random-firm [
      (ifelse use-index? [
        init-framework-agreement ((random 4) + 1) framework-duration
      ] [
        init-framework-agreement 0 framework-duration
      ])
    ]
  ]
end

;firm procedure, searches for a new supplier of a given input good to replace a supplier that was unable to satisfy the firm's demand
to search-delivery-capable-seller [input-i]
  let link-failed-to-satisfy rnd:weighted-one-of my-in-framework-agreements with [input-firm-type = input-i][demand-not-satisfied]
  if [demand-not-satisfied] of link-failed-to-satisfy > 0  [
    create-framework-agreement-from pick-random-input-firm input-i [
      (ifelse use-index? [
        init-framework-agreement ((random 4) + 1) framework-duration
      ] [
        init-framework-agreement 0 framework-duration
      ])
    ]
    ask link-failed-to-satisfy [die]
  ]
end

;firm procedure, picks a random firm that produces a given input, weighted by the number of employees
to-report pick-random-input-firm [input-i]
  report rnd:weighted-one-of firms with [not member? myself out-framework-agreement-neighbors and firm-type = input-i] [count my-employment-links]
end

;firm procedure, reports the current stock of a given input
to-report current-stock [i]
  let input table:get input-data i
  report table:get input "Current stock"
end

;firm procedure, sets the stock of a given input to a given value
to set-stock [input value]
  let current-input table:get input-data input
  table:put current-input "Current stock" value
end

;firm procedure, reports the marginal productivity of a given input as stored in the input information table
to-report marginal-productivity [i]
  let input table:get input-data i
  report table:get input "Marginal productivity"
end

;firm procedure, reports the number of employees a firm has
to-report n-workers
  report count my-employment-links
end

;firm procedure, adjusts inventory by a calculated production amount and adjusts input stocks accordingly by calling use-inputs
to produce-goods  
  let production-amount production-potential
  set inventory inventory + production-amount
  use-inputs production-amount
end

;firm procedure, pays wages to workers based on formula in Lengnick paper
to pay-wages
  if n-workers > 0 [
    while [wage-rate * n-workers > liquidity] [ 
      ask one-of my-employment-links [die]                   ; no change to desired-n-workers
    ]
    set liquidity precision (liquidity - wage-rate * n-workers) 10
    if liquidity < 0 [error "firms aren't allowed to go into debt after paying wages"]
    let temp-wr wage-rate
    ask employment-link-neighbors [set liquidity liquidity + temp-wr]
  ]
end

;firm procedure, distrubtes all profits allocated by firms to households
to distribute-profits 
  if liquidity < 0 [error "liquidity should not be negative"]  
  let buffer decide-reserve
  if liquidity > buffer [  ; if there is enough profits, allocate them to share holders
    let profits-to-allocate liquidity - buffer
    set liquidity buffer
    ;; distribute profits proportionately to initial investment
    let profits-to-be-allocated profits-to-allocate
    set lifetime-profits lifetime-profits + profits-to-be-allocated
    let total-equity sum [equity] of my-equity-links
    ask my-equity-links [
      if equity < 0 [error "equity must be positive"]
      let equity-percent equity / total-equity
      let share-of-profits equity-percent * profits-to-allocate  
      ask other-end [
        set liquidity liquidity + share-of-profits
        set profits-to-be-allocated profits-to-be-allocated - share-of-profits
      ]
    ]
    if precision profits-to-be-allocated 2 != 0 [error "profits weren't fully distributed"]
  ]
end


;firm procedure, sells a given amount of goods to a single consumer
to-report sell-consumption-good [amount-wanted]
  if amount-wanted < 0 [error "you cant want less than 0"]
  set demand demand + amount-wanted
  let goods-sold min list amount-wanted inventory  ; sell the amount wanted, or if the firm doesn't have enough, then all remaining inventory
  set inventory inventory - goods-sold
  set previous-sales previous-sales + goods-sold
  if inventory < 0 [error "inventory cannot be negative"]
  set liquidity liquidity + goods-sold * price
  report goods-sold
end

;firm procedure, decides how much to hold for distribution to households and for savings
to-report decide-reserve  
  report BUFFER-LABOR-FRACTION * wage-rate * n-workers
end

;firm procedure, reports the daily production potential of a firm based on the amount of inputs it has in stock
to-report production-potential 
  (ifelse table:length input-data = 0[
    report max-production
  ][
    let minimum-potential 1000000000
    let input-potential min map [i -> ((marginal-productivity i) * (current-stock i))] table:keys input-data
    report (min (list input-potential (max-production)))
  ])
end

;firm procedure, takes in a production amount and adjusts input stocks accordingly
to use-inputs [production-amount] 
  foreach table:keys input-data[ i ->
    let current-amount current-stock i
    set-stock i (current-amount - ((production-amount) / (marginal-productivity i)))
  ]
end

;firm procedure, reports the demand for a given input given the economy transacts
to-report input-demand-per-period [i]
  let input table:get input-data i
  report table:get input "Daily demand"
end

;firm procedure, sets the daily demand for a given input
to set-demand-per-period [i value]
  let input table:get input-data i
  table:put input "Daily demand" value
  table:put input-data i input
end

;firm procedure, sets the daily demands for all inputs by calling set-daily-demand, demand is determined by current stock and inventories
to set-input-demands
  let estimated-demand demand
  let estimated-production max (list 0 (estimated-demand - inventory))
  ;currently there's no buffer for how much of an input a firm orders, they order exactly as much as they think they'll need
  foreach table:keys input-data[i ->
    let current-amount current-stock i
    let amount-needed (estimated-production / (marginal-productivity i))
    ifelse amount-needed > current-amount[
      set-demand-per-period i ((amount-needed - current-amount) * transactions-per-month)
    ][
      set-demand-per-period i 0
    ]
  ]
end

;firm procedure, returns true if a firm uses a given input
to-report uses-input? [i]
  report table:has-key? input-data i
end

;firm procedure, sells a given amount of an good to a single firm
to-report sell-input-good [amount-wanted]
  if amount-wanted < 0 [error "you cant want less than 0"]
  set demand demand + amount-wanted
  let goods-sold min list amount-wanted inventory  ; sell the amount wanted, or if the firm doesn't have enough, then all remaining inventory
  set previous-sales previous-sales + goods-sold
  set inventory inventory - goods-sold
  if inventory < 0 [error "inventory cannot be negative"]
  set liquidity liquidity + goods-sold * price
  report goods-sold
end

;firm procedure, buys all necessary inputs for a day by asking some combination of framework agreement partners
to buy-input-goods
  foreach table:keys input-data[i ->
    let remaining-demand input-demand-per-period i
    let frameworks-to-try my-framework-agreements
    while [remaining-demand >= (0.05 * input-demand-per-period i) and any? frameworks-to-try][
      let the-framework one-of frameworks-to-try
      let current-price 0
      ask the-framework [set current-price framework-price]
      let goods-wanted min (list (input-demand-per-period i) (liquidity / current-price))
      let amount-bought [sell-input-good goods-wanted] of [end1] of the-framework
      set liquidity liquidity - amount-bought * current-price
      let current-amount current-stock i  
      set-stock i (current-amount + amount-bought)
      if liquidity < 0 and liquidity > -1E-5 [set liquidity 0]                   ; only fix rounding errors that go slightly under liquidity
      if liquidity < 0 [error "negative liquidity when buying input goods"]
      set remaining-demand remaining-demand - amount-bought
      if remaining-demand > 1E-10 [  ; if the amount bought does not satisfy demand (either because the firm didn't have inventory or because it was too expensive and the house couldn't afford)
        ask the-framework [set demand-not-satisfied remaining-demand]
      ]
      ask the-framework [ set frameworks-to-try other frameworks-to-try]  ; remove this firm from the available set of firms to try
    ]
  ]
end


;firm procedure, reports the number of agreements a given firm has with firms of a given supplier type (how many suppliers a firm has for a given input)
to-report n-in-agreements [input]
  report count my-in-framework-agreements with [input-firm-type = input]
end

;firm procedure, reports the number of outgoing framework agreements a firm has (how many firms a firm supplies)
to-report n-out-agreements
  report count my-out-framework-agreements
end

;firm procedure, reports the input type of a framework agreement
to-report input-firm-type
   report [firm-type] of end1
end

;firm procedure, reports the maximum production possible
to-report max-production
  report n-workers * tech-parameter
end

;firm procedure, reports an agentset of firms with the same firm-type as the caller
to-report firms-with-my-type
  let curr-firm self
  report firms with [firm-type = [firm-type] of curr-firm]
end

;framework-agreement procedure, reports the price given the index-type and the price multiplier
to-report framework-price
  (ifelse index-type = 0 [
    report index-multiplier
  ] 
  index-type = 1 [
    report index-multiplier * pringle-index-value
  ] 
  index-type = 2 [
    report index-multiplier * coats-index-value
  ] 
  index-type = 3 [
    report index-multiplier * ussher-index-value
  ] 
  index-type = 4 [
    report index-multiplier * potvin-index-value
  ])
end